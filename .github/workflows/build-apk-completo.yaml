name: 🚀 Build APK - Corte de Matos (COMPLETO)

on:
  workflow_dispatch:
    inputs:
      profile:
        description: 'Build profile'
        required: true
        default: 'preview'
        type: choice
        options:
          - preview
          - production

jobs:
  build:
    name: 📱 Build Android APK - Corte de Matos
    runs-on: ubuntu-latest
    timeout-minutes: 60
    steps:
      - name: 📥 Checkout repository
        uses: actions/checkout@v4

      - name: 🟢 Setup Node.js 20
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: ☕ Setup Java 17
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: 📦 Install dependencies
        run: |
          echo "📦 Instalando dependências do zero..."
          # Remover diretórios que podem conter informações de cache
          rm -rf node_modules package-lock.json yarn.lock
          # Criar novo package.json para o build
          cat > package.json << 'EOF'
          {
            "name": "corte-matos-app",
            "version": "1.1.0",
            "main": "App.js",
            "scripts": {
              "start": "expo start",
              "android": "expo start --android",
              "ios": "expo start --ios",
              "web": "expo start --web"
            },
            "dependencies": {
              "@react-native-async-storage/async-storage": "^1.18.2",
              "expo": "~50.0.6",
              "expo-constants": "~15.4.2",
              "expo-document-picker": "~11.10.1",
              "expo-print": "~12.8.1",
              "expo-sharing": "~11.10.0",
              "expo-status-bar": "~1.11.1",
              "expo-build-properties": "~0.11.1",
              "react": "18.2.0",
              "react-native": "0.73.4",
              "react-native-elements": "^3.4.3",
              "xlsx": "^0.18.5"
            },
            "devDependencies": {
              "@babel/core": "^7.20.0",
              "babel-preset-expo": "^10.0.0"
            },
            "overrides": {
              "jimp-compact": "0.16.1"
            },
            "private": true
          }
          EOF
          # Instalar dependências a partir do novo package.json
          npm install --legacy-peer-deps
          
      - name: 🔧 Setup Expo CLI
        run: |
          echo "🔧 Instalando Expo CLI e EAS CLI..."
          npm install -g @expo/cli@latest eas-cli@latest
          npx eas-cli --version
          npx expo --version

      - name: 📝 Criar App.js
        run: |
          cat > App.js << 'EOF'
          import React, { useState, useEffect } from 'react';
          import { StyleSheet, Text, View, TouchableOpacity, FlatList, Alert, Modal, TextInput, Button, ScrollView, Image } from 'react-native';
          import * as DocumentPicker from 'expo-document-picker';
          import * as Sharing from 'expo-sharing';
          import * as Print from 'expo-print';
          import { StatusBar } from 'expo-status-bar';
          import AsyncStorage from '@react-native-async-storage/async-storage';
          import { MaterialIcons } from '@expo/vector-icons';
          import XLSX from 'xlsx';

          // Componente de status de sincronização
          const SyncStatus = ({ lastSync, isOnline, onSync }) => {
            return (
              <View style={styles.syncContainer}>
                <Text style={styles.syncText}>
                  Status: {isOnline ? 'Online 🟢' : 'Offline 🔴'}
                </Text>
                <Text style={styles.syncText}>
                  Última sincronização: {lastSync || 'Nunca'}
                </Text>
                <TouchableOpacity
                  style={[styles.syncButton, !isOnline && styles.syncButtonDisabled]}
                  onPress={onSync}
                  disabled={!isOnline}
                >
                  <Text style={styles.syncButtonText}>Sincronizar</Text>
                </TouchableOpacity>
              </View>
            );
          };

          // Componente Login
          const LoginScreen = ({ onLogin }) => {
            const [username, setUsername] = useState('');
            const [password, setPassword] = useState('');
            const [error, setError] = useState('');

            const handleLogin = () => {
              // Usuários permitidos (em produção, seria armazenado no servidor)
              const users = [
                { username: 'admin', password: 'admin123', role: 'admin' },
                { username: 'user', password: 'user123', role: 'user' }
              ];

              const user = users.find(
                (u) => u.username === username && u.password === password
              );

              if (user) {
                onLogin(user);
                setError('');
              } else {
                setError('Usuário ou senha inválidos');
              }
            };

            return (
              <View style={styles.loginContainer}>
                <View style={styles.logoContainer}>
                  <MaterialIcons name="nature" size={80} color="#4CAF50" />
                  <Text style={styles.logoText}>Corte de Matos</Text>
                </View>
                <View style={styles.formContainer}>
                  <TextInput
                    style={styles.input}
                    placeholder="Usuário"
                    value={username}
                    onChangeText={setUsername}
                    autoCapitalize="none"
                  />
                  <TextInput
                    style={styles.input}
                    placeholder="Senha"
                    value={password}
                    onChangeText={setPassword}
                    secureTextEntry
                  />
                  {error ? <Text style={styles.errorText}>{error}</Text> : null}
                  <TouchableOpacity style={styles.loginButton} onPress={handleLogin}>
                    <Text style={styles.loginButtonText}>Entrar</Text>
                  </TouchableOpacity>
                </View>
              </View>
            );
          };

          export default function App() {
            const [vaos, setVaos] = useState([]);
            const [modalVisible, setModalVisible] = useState(false);
            const [selectedVao, setSelectedVao] = useState(null);
            const [user, setUser] = useState(null);
            const [isOnline, setIsOnline] = useState(false);
            const [lastSync, setLastSync] = useState(null);

            // Carrega usuário do armazenamento local
            useEffect(() => {
              const loadUser = async () => {
                try {
                  const savedUser = await AsyncStorage.getItem('user');
                  if (savedUser) {
                    setUser(JSON.parse(savedUser));
                  }
                } catch (error) {
                  console.error('Erro ao carregar usuário:', error);
                }
              };

              loadUser();
              
              // Simulação de status online
              const interval = setInterval(() => {
                // Simulando conexão online/offline (70% chance de estar online)
                setIsOnline(Math.random() > 0.3);
              }, 10000);
              
              return () => clearInterval(interval);
            }, []);

            // Carrega vaos do armazenamento local
            useEffect(() => {
              const loadVaos = async () => {
                try {
                  const savedVaos = await AsyncStorage.getItem('vaos');
                  if (savedVaos) {
                    setVaos(JSON.parse(savedVaos));
                  }
                } catch (error) {
                  console.error('Erro ao carregar vaos:', error);
                }
              };

              loadVaos();
            }, []);

            // Salva vaos no armazenamento local
            useEffect(() => {
              const saveVaos = async () => {
                try {
                  await AsyncStorage.setItem('vaos', JSON.stringify(vaos));
                } catch (error) {
                  console.error('Erro ao salvar vaos:', error);
                }
              };

              if (vaos.length > 0) {
                saveVaos();
              }
            }, [vaos]);

            const handleLogin = async (loggedUser) => {
              setUser(loggedUser);
              try {
                await AsyncStorage.setItem('user', JSON.stringify(loggedUser));
              } catch (error) {
                console.error('Erro ao salvar usuário:', error);
              }
            };

            const handleLogout = async () => {
              setUser(null);
              try {
                await AsyncStorage.removeItem('user');
              } catch (error) {
                console.error('Erro ao remover usuário:', error);
              }
            };

            const handleSync = () => {
              if (!isOnline) {
                Alert.alert("Erro", "Você está offline. Não é possível sincronizar.");
                return;
              }
              
              // Simulação de sincronização
              Alert.alert(
                "Sincronização",
                "Sincronizando dados com o servidor...",
                [{ text: "OK" }]
              );
              
              const now = new Date().toLocaleString();
              setLastSync(now);
              
              // Salvar data de sincronização
              AsyncStorage.setItem('lastSync', now);
            };

            const pickExcel = async () => {
              try {
                const result = await DocumentPicker.getDocumentAsync({
                  type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
                });

                if (result.canceled) {
                  return;
                }

                const { uri } = result.assets[0];
                const response = await fetch(uri);
                const blob = await response.blob();
                const reader = new FileReader();

                reader.onload = (e) => {
                  const data = new Uint8Array(e.target.result);
                  const workbook = XLSX.read(data, { type: 'array' });
                  const sheetName = workbook.SheetNames[0];
                  const worksheet = workbook.Sheets[sheetName];
                  const jsonData = XLSX.utils.sheet_to_json(worksheet);

                  // Transformando os dados do Excel
                  const newVaos = jsonData.map((item, index) => ({
                    id: Date.now() + index,
                    descricao: item.Descricao || 'Sem descrição',
                    localizacao: item.Localizacao || 'Sem localização',
                    area: item.Area || 0,
                    dataNecessidade: item.DataNecessidade || new Date().toISOString().split('T')[0],
                    status: 'pendente',
                    dataInicio: null,
                    dataConclusao: null,
                  }));

                  setVaos([...vaos, ...newVaos]);
                  Alert.alert('Sucesso', `${newVaos.length} vãos importados com sucesso!`);
                };

                reader.readAsArrayBuffer(blob);
              } catch (error) {
                console.error('Erro ao ler o arquivo:', error);
                Alert.alert('Erro', 'Não foi possível ler o arquivo Excel.');
              }
            };

            const openVaoDetails = (vao) => {
              setSelectedVao(vao);
              setModalVisible(true);
            };

            const updateVaoStatus = (id, newStatus) => {
              const updatedVaos = vaos.map((vao) => {
                if (vao.id === id) {
                  if (newStatus === 'iniciado' && vao.status === 'pendente') {
                    return { ...vao, status: newStatus, dataInicio: new Date().toISOString().split('T')[0] };
                  } else if (newStatus === 'concluido' && (vao.status === 'pendente' || vao.status === 'iniciado')) {
                    return { 
                      ...vao, 
                      status: newStatus, 
                      dataInicio: vao.dataInicio || new Date().toISOString().split('T')[0],
                      dataConclusao: new Date().toISOString().split('T')[0] 
                    };
                  }
                }
                return vao;
              });

              setVaos(updatedVaos);
              setModalVisible(false);
            };

            const getStatusColor = (status) => {
              switch (status) {
                case 'pendente':
                  return '#9E9E9E';
                case 'iniciado':
                  return '#FFC107';
                case 'concluido':
                  return '#4CAF50';
                default:
                  return '#9E9E9E';
              }
            };

            const getStatusText = (status) => {
              switch (status) {
                case 'pendente':
                  return 'Pendente';
                case 'iniciado':
                  return 'Iniciado';
                case 'concluido':
                  return 'Concluído';
                default:
                  return 'Desconhecido';
              }
            };

            const isUrgent = (dataNecessidade) => {
              const today = new Date();
              const necessidade = new Date(dataNecessidade);
              const diffTime = necessidade - today;
              const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
              return diffDays <= 7 && diffDays > 0;
            };

            const isLate = (dataNecessidade) => {
              const today = new Date();
              const necessidade = new Date(dataNecessidade);
              return necessidade < today;
            };

            const generateReport = async () => {
              try {
                const pendentes = vaos.filter(vao => vao.status === 'pendente').length;
                const iniciados = vaos.filter(vao => vao.status === 'iniciado').length;
                const concluidos = vaos.filter(vao => vao.status === 'concluido').length;
                const total = vaos.length;
                
                const percentConcluido = total > 0 ? Math.round((concluidos / total) * 100) : 0;
                
                let vaosList = '';
                vaos.forEach(vao => {
                  vaosList += `
                    <tr>
                      <td>${vao.descricao}</td>
                      <td>${vao.localizacao}</td>
                      <td>${vao.area}</td>
                      <td>${vao.dataNecessidade}</td>
                      <td style="color: ${getStatusColor(vao.status)}">${getStatusText(vao.status)}</td>
                    </tr>
                  `;
                });

                const html = `
                  <html>
                    <head>
                      <style>
                        body { font-family: Arial, sans-serif; padding: 20px; }
                        h1 { color: #4CAF50; text-align: center; }
                        .header { text-align: center; margin-bottom: 30px; }
                        .summary { margin: 20px 0; padding: 15px; background-color: #f5f5f5; border-radius: 5px; }
                        .progress-container { height: 20px; background-color: #e0e0e0; border-radius: 10px; margin: 15px 0; }
                        .progress-bar { height: 100%; width: ${percentConcluido}%; background-color: #4CAF50; border-radius: 10px; }
                        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
                        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
                        th { background-color: #4CAF50; color: white; }
                        tr:nth-child(even) { background-color: #f2f2f2; }
                        .footer { margin-top: 30px; text-align: center; font-size: 12px; color: #666; }
                      </style>
                    </head>
                    <body>
                      <div class="header">
                        <h1>Relatório de Corte de Matos</h1>
                        <p>Data de geração: ${new Date().toLocaleDateString()}</p>
                      </div>
                      
                      <div class="summary">
                        <h2>Resumo</h2>
                        <p>Total de vãos: ${total}</p>
                        <p>Pendentes: ${pendentes}</p>
                        <p>Iniciados: ${iniciados}</p>
                        <p>Concluídos: ${concluidos}</p>
                        
                        <h3>Progresso: ${percentConcluido}%</h3>
                        <div class="progress-container">
                          <div class="progress-bar"></div>
                        </div>
                      </div>
                      
                      <h2>Detalhes dos Vãos</h2>
                      <table>
                        <thead>
                          <tr>
                            <th>Descrição</th>
                            <th>Localização</th>
                            <th>Área</th>
                            <th>Data Necessidade</th>
                            <th>Status</th>
                          </tr>
                        </thead>
                        <tbody>
                          ${vaosList}
                        </tbody>
                      </table>
                      
                      <div class="footer">
                        <p>Aplicativo de Controle de Corte de Matos - v1.1.0</p>
                      </div>
                    </body>
                  </html>
                `;

                const { uri } = await Print.printToFileAsync({ html });
                
                if (await Sharing.isAvailableAsync()) {
                  await Sharing.shareAsync(uri);
                } else {
                  Alert.alert(
                    'Erro',
                    'Compartilhamento não está disponível neste dispositivo'
                  );
                }
              } catch (error) {
                console.error('Erro ao gerar relatório:', error);
                Alert.alert('Erro', 'Não foi possível gerar o relatório.');
              }
            };

            if (!user) {
              return <LoginScreen onLogin={handleLogin} />;
            }

            return (
              <View style={styles.container}>
                <View style={styles.header}>
                  <Text style={styles.title}>Corte de Matos</Text>
                  <View style={styles.userInfo}>
                    <Text style={styles.userText}>
                      {user.username} ({user.role === 'admin' ? 'Admin' : 'Usuário'})
                    </Text>
                    <TouchableOpacity onPress={handleLogout} style={styles.logoutButton}>
                      <MaterialIcons name="exit-to-app" size={24} color="white" />
                    </TouchableOpacity>
                  </View>
                </View>

                <SyncStatus 
                  isOnline={isOnline} 
                  lastSync={lastSync} 
                  onSync={handleSync} 
                />

                <View style={styles.actions}>
                  {user.role === 'admin' && (
                    <TouchableOpacity style={styles.button} onPress={pickExcel}>
                      <MaterialIcons name="file-upload" size={24} color="white" />
                      <Text style={styles.buttonText}>Importar Excel</Text>
                    </TouchableOpacity>
                  )}
                  
                  <TouchableOpacity style={styles.button} onPress={generateReport}>
                    <MaterialIcons name="description" size={24} color="white" />
                    <Text style={styles.buttonText}>Gerar Relatório</Text>
                  </TouchableOpacity>
                </View>

                <Text style={styles.sectionTitle}>Lista de Vãos ({vaos.length})</Text>
                
                {vaos.length > 0 ? (
                  <FlatList
                    data={vaos}
                    keyExtractor={(item) => item.id.toString()}
                    renderItem={({ item }) => (
                      <TouchableOpacity
                        style={[
                          styles.vaoItem,
                          { borderLeftColor: getStatusColor(item.status) }
                        ]}
                        onPress={() => openVaoDetails(item)}
                      >
                        <View style={styles.vaoHeader}>
                          <Text style={styles.vaoTitle}>{item.descricao}</Text>
                          <View style={styles.vaoStatusContainer}>
                            {isUrgent(item.dataNecessidade) && !isLate(item.dataNecessidade) && (
                              <Text style={styles.urgentIcon}>🕐</Text>
                            )}
                            {isLate(item.dataNecessidade) && item.status !== 'concluido' && (
                              <Text style={styles.lateIcon}>⚠️</Text>
                            )}
                            <View 
                              style={[
                                styles.vaoStatusBadge, 
                                { backgroundColor: getStatusColor(item.status) }
                              ]}
                            >
                              <Text style={styles.vaoStatusText}>{getStatusText(item.status)}</Text>
                            </View>
                          </View>
                        </View>
                        
                        <Text style={styles.vaoLocation}>{item.localizacao}</Text>
                        <Text style={styles.vaoArea}>Área: {item.area}m²</Text>
                        <Text style={[
                          styles.vaoDate,
                          isLate(item.dataNecessidade) && item.status !== 'concluido' ? styles.lateDate : null,
                          isUrgent(item.dataNecessidade) && !isLate(item.dataNecessidade) ? styles.urgentDate : null
                        ]}>
                          Data necessidade: {item.dataNecessidade}
                        </Text>
                      </TouchableOpacity>
                    )}
                  />
                ) : (
                  <View style={styles.emptyContainer}>
                    <MaterialIcons name="nature" size={80} color="#e0e0e0" />
                    <Text style={styles.emptyText}>Nenhum vão cadastrado</Text>
                    {user.role === 'admin' ? (
                      <Text style={styles.emptySubText}>Importe um arquivo Excel para começar</Text>
                    ) : (
                      <Text style={styles.emptySubText}>Aguarde o administrador importar os dados</Text>
                    )}
                  </View>
                )}

                <Modal
                  animationType="slide"
                  transparent={true}
                  visible={modalVisible}
                  onRequestClose={() => setModalVisible(false)}
                >
                  <View style={styles.modalContainer}>
                    <View style={styles.modalContent}>
                      {selectedVao && (
                        <>
                          <View style={styles.modalHeader}>
                            <Text style={styles.modalTitle}>{selectedVao.descricao}</Text>
                            <TouchableOpacity 
                              style={styles.closeButton} 
                              onPress={() => setModalVisible(false)}
                            >
                              <MaterialIcons name="close" size={24} color="#333" />
                            </TouchableOpacity>
                          </View>
                          
                          <ScrollView style={styles.modalBody}>
                            <View style={styles.modalSection}>
                              <Text style={styles.modalLabel}>Localização:</Text>
                              <Text style={styles.modalValue}>{selectedVao.localizacao}</Text>
                            </View>
                            
                            <View style={styles.modalSection}>
                              <Text style={styles.modalLabel}>Área:</Text>
                              <Text style={styles.modalValue}>{selectedVao.area}m²</Text>
                            </View>
                            
                            <View style={styles.modalSection}>
                              <Text style={styles.modalLabel}>Data de necessidade:</Text>
                              <Text style={[
                                styles.modalValue,
                                isLate(selectedVao.dataNecessidade) && selectedVao.status !== 'concluido' ? styles.lateDate : null
                              ]}>
                                {selectedVao.dataNecessidade}
                                {isLate(selectedVao.dataNecessidade) && selectedVao.status !== 'concluido' && ' ⚠️ ATRASADO'}
                              </Text>
                            </View>
                            
                            <View style={styles.modalSection}>
                              <Text style={styles.modalLabel}>Status atual:</Text>
                              <View style={[
                                styles.statusBadge,
                                { backgroundColor: getStatusColor(selectedVao.status) }
                              ]}>
                                <Text style={styles.statusBadgeText}>{getStatusText(selectedVao.status)}</Text>
                              </View>
                            </View>
                            
                            {selectedVao.dataInicio && (
                              <View style={styles.modalSection}>
                                <Text style={styles.modalLabel}>Data de início:</Text>
                                <Text style={styles.modalValue}>{selectedVao.dataInicio}</Text>
                              </View>
                            )}
                            
                            {selectedVao.dataConclusao && (
                              <View style={styles.modalSection}>
                                <Text style={styles.modalLabel}>Data de conclusão:</Text>
                                <Text style={styles.modalValue}>{selectedVao.dataConclusao}</Text>
                              </View>
                            )}
                          </ScrollView>
                          
                          <View style={styles.modalActions}>
                            {selectedVao.status === 'pendente' && (
                              <>
                                <TouchableOpacity
                                  style={[styles.actionButton, styles.startButton]}
                                  onPress={() => updateVaoStatus(selectedVao.id, 'iniciado')}
                                >
                                  <MaterialIcons name="play-arrow" size={18} color="white" />
                                  <Text style={styles.actionButtonText}>Iniciar</Text>
                                </TouchableOpacity>
                                
                                <TouchableOpacity
                                  style={[styles.actionButton, styles.completeButton]}
                                  onPress={() => updateVaoStatus(selectedVao.id, 'concluido')}
                                >
                                  <MaterialIcons name="check" size={18} color="white" />
                                  <Text style={styles.actionButtonText}>Concluir</Text>
                                </TouchableOpacity>
                              </>
                            )}
                            
                            {selectedVao.status === 'iniciado' && (
                              <TouchableOpacity
                                style={[styles.actionButton, styles.completeButton]}
                                onPress={() => updateVaoStatus(selectedVao.id, 'concluido')}
                              >
                                <MaterialIcons name="check" size={18} color="white" />
                                <Text style={styles.actionButtonText}>Concluir</Text>
                              </TouchableOpacity>
                            )}
                          </View>
                        </>
                      )}
                    </View>
                  </View>
                </Modal>

                <StatusBar style="auto" />
              </View>
            );
          }

          const styles = StyleSheet.create({
            container: {
              flex: 1,
              backgroundColor: '#f5f5f5',
            },
            header: {
              backgroundColor: '#4CAF50',
              padding: 16,
              paddingTop: 50,
              flexDirection: 'row',
              justifyContent: 'space-between',
              alignItems: 'center',
            },
            title: {
              color: 'white',
              fontSize: 20,
              fontWeight: 'bold',
            },
            userInfo: {
              flexDirection: 'row',
              alignItems: 'center',
            },
            userText: {
              color: 'white',
              marginRight: 8,
            },
            logoutButton: {
              padding: 5,
            },
            actions: {
              flexDirection: 'row',
              padding: 16,
              justifyContent: 'space-around',
            },
            button: {
              backgroundColor: '#4CAF50',
              flexDirection: 'row',
              alignItems: 'center',
              padding: 10,
              borderRadius: 5,
              minWidth: 150,
              justifyContent: 'center',
            },
            buttonText: {
              color: 'white',
              marginLeft: 8,
            },
            sectionTitle: {
              fontSize: 18,
              fontWeight: 'bold',
              margin: 16,
              marginBottom: 8,
            },
            vaoItem: {
              backgroundColor: 'white',
              padding: 16,
              marginHorizontal: 16,
              marginBottom: 8,
              borderRadius: 5,
              borderLeftWidth: 5,
              elevation: 2,
            },
            vaoHeader: {
              flexDirection: 'row',
              justifyContent: 'space-between',
              alignItems: 'center',
              marginBottom: 5,
            },
            vaoTitle: {
              fontSize: 16,
              fontWeight: 'bold',
              flex: 1,
            },
            vaoStatusContainer: {
              flexDirection: 'row',
              alignItems: 'center',
            },
            vaoStatusBadge: {
              paddingHorizontal: 8,
              paddingVertical: 3,
              borderRadius: 10,
            },
            vaoStatusText: {
              color: 'white',
              fontSize: 12,
            },
            vaoLocation: {
              color: '#555',
              marginBottom: 5,
            },
            vaoArea: {
              color: '#555',
              marginBottom: 5,
            },
            vaoDate: {
              color: '#555',
            },
            lateDate: {
              color: '#d32f2f',
              fontWeight: 'bold',
            },
            urgentDate: {
              color: '#ff9800',
              fontWeight: 'bold',
            },
            urgentIcon: {
              marginRight: 5,
              fontSize: 16,
            },
            lateIcon: {
              marginRight: 5,
              fontSize: 16,
            },
            emptyContainer: {
              flex: 1,
              justifyContent: 'center',
              alignItems: 'center',
              padding: 20,
            },
            emptyText: {
              fontSize: 18,
              fontWeight: 'bold',
              color: '#9e9e9e',
              marginTop: 10,
            },
            emptySubText: {
              color: '#9e9e9e',
              textAlign: 'center',
              marginTop: 5,
            },
            modalContainer: {
              flex: 1,
              justifyContent: 'center',
              alignItems: 'center',
              backgroundColor: 'rgba(0, 0, 0, 0.5)',
            },
            modalContent: {
              backgroundColor: 'white',
              width: '90%',
              borderRadius: 10,
              overflow: 'hidden',
              maxHeight: '80%',
            },
            modalHeader: {
              flexDirection: 'row',
              justifyContent: 'space-between',
              alignItems: 'center',
              padding: 16,
              backgroundColor: '#f5f5f5',
              borderBottomWidth: 1,
              borderBottomColor: '#e0e0e0',
            },
            modalTitle: {
              fontSize: 18,
              fontWeight: 'bold',
              flex: 1,
            },
            closeButton: {
              padding: 5,
            },
            modalBody: {
              padding: 16,
              maxHeight: 300,
            },
            modalSection: {
              marginBottom: 12,
            },
            modalLabel: {
              color: '#666',
              fontSize: 14,
              marginBottom: 2,
            },
            modalValue: {
              fontSize: 16,
            },
            statusBadge: {
              alignSelf: 'flex-start',
              paddingHorizontal: 10,
              paddingVertical: 5,
              borderRadius: 15,
              marginTop: 2,
            },
            statusBadgeText: {
              color: 'white',
              fontWeight: 'bold',
            },
            modalActions: {
              flexDirection: 'row',
              justifyContent: 'flex-end',
              padding: 16,
              borderTopWidth: 1,
              borderTopColor: '#e0e0e0',
            },
            actionButton: {
              flexDirection: 'row',
              alignItems: 'center',
              paddingVertical: 8,
              paddingHorizontal: 12,
              borderRadius: 5,
              marginLeft: 8,
            },
            actionButtonText: {
              color: 'white',
              marginLeft: 5,
              fontWeight: 'bold',
            },
            startButton: {
              backgroundColor: '#FFC107',
            },
            completeButton: {
              backgroundColor: '#4CAF50',
            },
            // Login styles
            loginContainer: {
              flex: 1,
              justifyContent: 'center',
              alignItems: 'center',
              backgroundColor: '#f5f5f5',
              padding: 20,
            },
            logoContainer: {
              alignItems: 'center',
              marginBottom: 40,
            },
            logoText: {
              fontSize: 28,
              fontWeight: 'bold',
              color: '#4CAF50',
              marginTop: 10,
            },
            formContainer: {
              width: '100%',
              maxWidth: 300,
            },
            input: {
              backgroundColor: 'white',
              padding: 15,
              borderRadius: 5,
              marginBottom: 15,
              borderWidth: 1,
              borderColor: '#ddd',
            },
            errorText: {
              color: 'red',
              marginBottom: 15,
              textAlign: 'center',
            },
            loginButton: {
              backgroundColor: '#4CAF50',
              padding: 15,
              borderRadius: 5,
              alignItems: 'center',
            },
            loginButtonText: {
              color: 'white',
              fontWeight: 'bold',
              fontSize: 16,
            },
            // Sync styles
            syncContainer: {
              backgroundColor: '#e8f5e9',
              padding: 10,
              margin: 16,
              borderRadius: 5,
              flexDirection: 'row',
              justifyContent: 'space-between',
              alignItems: 'center',
              flexWrap: 'wrap',
            },
            syncText: {
              fontSize: 12,
              color: '#2e7d32',
              marginRight: 5,
            },
            syncButton: {
              backgroundColor: '#4CAF50',
              paddingHorizontal: 10,
              paddingVertical: 5,
              borderRadius: 15,
            },
            syncButtonDisabled: {
              backgroundColor: '#9E9E9E',
            },
            syncButtonText: {
              color: 'white',
              fontSize: 12,
            },
          });
          EOF

      - name: 🔐 Authenticate with Expo
        run: |
          echo "🔐 Autenticando com Expo..."
        env:
          EXPO_TOKEN: ${{ secrets.EXPO_TOKEN }}

      - name: 🖼️ Garantir assets do app
        run: |
          mkdir -p assets
          if [ ! -f assets/icon.png ]; then
            # Criando ícones válidos com cores sólidas simples (evita erros de CRC)
            convert -size 1024x1024 xc:#4CAF50 assets/icon.png || {
              # Fallback se o ImageMagick não estiver disponível
              echo "Instalando ImageMagick..."
              sudo apt-get update -qq && sudo apt-get install -y imagemagick
              convert -size 1024x1024 xc:#4CAF50 assets/icon.png
            }
            
            # Copiando para outros ícones necessários
            cp assets/icon.png assets/adaptive-icon.png
            cp assets/icon.png assets/splash.png
            cp assets/icon.png assets/favicon.png
            
            echo "✅ Ícones criados com sucesso"
            ls -la assets/
          fi
          
      - name: 🔧 Preparar ambiente Android
        run: |
          echo "🔧 Instalando dependências do Android SDK..."
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            build-essential \
            file \
            curl \
            sudo \
            git
          
          # Definir variáveis de ambiente Android - Corrigir conflito de SDK paths
          # Remover ANDROID_SDK_ROOT se existir
          if [ -n "$ANDROID_SDK_ROOT" ]; then
            echo "Limpando variável ANDROID_SDK_ROOT conflitante..."
            unset ANDROID_SDK_ROOT
          fi
          
          # Configuração do ANDROID_HOME único e consistente
          export ANDROID_HOME=$HOME/android-sdk
          mkdir -p $ANDROID_HOME
          
          # Adicionar ao GITHUB_ENV para persistir em todos os passos
          echo "ANDROID_HOME=$ANDROID_HOME" >> $GITHUB_ENV
          echo "PATH=$PATH:$ANDROID_HOME/cmdline-tools/latest/bin:$ANDROID_HOME/platform-tools" >> $GITHUB_ENV
          
          # Remover qualquer referência ao ANDROID_SDK_ROOT nas variáveis de ambiente
          echo "Garantindo que apenas ANDROID_HOME seja usado..."
          sudo rm -f /etc/environment.d/*android*.conf || true
          
          # Instalar Android build tools necessários para o EAS
          sudo npm install -g turtle-cli --unsafe-perm

      - name: 📝 Garantir app.json
        run: |
          cat > app.json << 'EOF'
          {
            "expo": {
              "name": "Corte de Matos",
              "slug": "corte-matos-app",
              "version": "1.1.0",
              "orientation": "portrait",
              "icon": "./assets/icon.png",
              "userInterfaceStyle": "light",
              "splash": {
                "image": "./assets/splash.png",
                "resizeMode": "contain",
                "backgroundColor": "#4CAF50"
              },
              "assetBundlePatterns": [
                "**/*"
              ],
              "android": {
                "adaptiveIcon": {
                  "foregroundImage": "./assets/adaptive-icon.png",
                  "backgroundColor": "#4CAF50"
                },
                "package": "com.pikulito.cortematos",
                "versionCode": 6,
                "compileSdkVersion": 34,
                "targetSdkVersion": 34,
                "permissions": []
              },
              "plugins": [
                [
                  "expo-build-properties",
                  {
                    "android": {
                      "compileSdkVersion": 34,
                      "targetSdkVersion": 34,
                      "buildToolsVersion": "34.0.0"
                    }
                  }
                ]
              ],
              "extra": {
                "eas": {
                  "projectId": "84ea4587-b864-4560-a167-05855903311c"
                }
              },
              "runtimeVersion": {
                "policy": "sdkVersion"
              },
              "updates": {
                "fallbackToCacheTimeout": 0,
                "enabled": false
              },
              "owner": "pikulito",
              "experiments": {
                "tsconfigPaths": true
              },
              "packagerOpts": {
                "sourceExts": ["js", "jsx", "ts", "tsx", "json"]
              }
            }
          }
          EOF

      - name: � Garantir babel.config.js
        run: |
          cat > babel.config.js << 'EOF'
          module.exports = function(api) {
            api.cache(true);
            return {
              presets: ['babel-preset-expo'],
            };
          };
          EOF
      
      - name: 🛠️ Preparar e reparar prebuild manualmente
        run: |
          echo "🛠️ Preparando prebuild manualmente para evitar problemas de CRC..."
          
          # Verificar se o diretório android existe e removê-lo se necessário
          if [ -d "android" ]; then
            echo "Removendo diretório android existente..."
            rm -rf android
          fi
          
          # Verificar se o diretório ios existe e removê-lo se necessário
          if [ -d "ios" ]; then
            echo "Removendo diretório ios existente..."
            rm -rf ios
          fi
          
          # Corrigir potenciais problemas de dependências
          echo "Instalando dependências específicas para prebuild..."
          npm install --save-dev @babel/core@^7.20.0 babel-preset-expo@latest
          
          # Verificar a estrutura e permissões das pastas de assets
          echo "Verificando e corrigindo estrutura de assets..."
          chmod -R 755 assets
          
          # Criar metro.config.js para garantir configuração correta
          cat > metro.config.js << 'EOF'
          const { getDefaultConfig } = require('@expo/metro-config');
          const defaultConfig = getDefaultConfig(__dirname);
          
          defaultConfig.resolver.assetExts.push('bin');
          
          module.exports = defaultConfig;
          EOF
          
          # Criar arquivo gradle.properties personalizado para corrigir o erro do SoftwareComponent
          mkdir -p android
          cat > android/gradle.properties << 'EOF'
          # Project-wide Gradle settings
          org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
          android.useAndroidX=true
          android.enableJetifier=true
          android.nonTransitiveRClass=true

          # Solucionar erro de "SoftwareComponent named 'release' not found"
          android.disableAutomaticComponentCreation=true
          EOF
          
          echo "Prebuild manual concluído."
          ls -la

      - name: � Garantir eas.json
        run: |
          if [ -n "${{ secrets.ANDROID_KEYSTORE }}" ]; then
            echo "${{ secrets.ANDROID_KEYSTORE }}" | base64 --decode > my-release-key.jks
            KEYSTORE_PASSWORD="${{ secrets.ANDROID_KEYSTORE_PASSWORD }}"
            KEY_ALIAS="${{ secrets.ANDROID_KEY_ALIAS }}"
            KEY_PASSWORD="${{ secrets.ANDROID_KEY_PASSWORD }}"
          else
            keytool -genkeypair -v -keystore my-release-key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias upload -storepass "temppassword" -keypass "temppassword" -dname "CN=Example, OU=Android, O=Example, L=Example, S=Example, C=US"
            KEYSTORE_PASSWORD="temppassword"
            KEY_ALIAS="upload"
            KEY_PASSWORD="temppassword"
          fi
          echo '{
            "android": {
              "keystore": {
                "keystorePath": "./my-release-key.jks",
                "keystorePassword": "'$KEYSTORE_PASSWORD'",
                "keyAlias": "'$KEY_ALIAS'",
                "keyPassword": "'$KEY_PASSWORD'"
              }
            }
          }' > credentials.json
          cat credentials.json

      - name: 🔧 Garantir eas.json
        run: |
          cat > eas.json << 'EOF'
          {
            "cli": {
              "version": ">= 7.0.0",
              "appVersionSource": "local"
            },
            "build": {
              "preview": {
                "distribution": "internal",
                "android": {
                  "buildType": "apk",
                  "credentialsSource": "local"
                }
              },
              "production": {
                "android": {
                  "buildType": "app-bundle",
                  "credentialsSource": "local"
                }
              }
            }
          }
          EOF

      - name: 🔨 Build Corte de Matos APK
        run: |
          echo "🔨 Build APK completo do Corte de Matos..."
          
          # Criar um diretório temporário para o build
          mkdir -p build-output
          
          # Verificar arquivos críticos
          ls -la
          echo "Verificando credenciais:"
          cat credentials.json
          echo "Verificando app.json:"
          cat app.json
          echo "Verificando eas.json:"
          cat eas.json
          
          # Exportar variáveis para evitar problemas com prebuild
          export EAS_NO_VCS=1
          export CI=1
          export EAS_LOCAL_BUILD_SKIP_CLEANUP=1
          export EAS_LOCAL_BUILD_ARTIFACTS_DIR=./build-output
          export EXPO_DEBUG=1
          
          echo "Usando perfil de build: ${{ github.event.inputs.profile || 'preview' }}"
          
          # Usar uma abordagem alternativa para o build
          echo "Tentando prebuild e build manual..."
          
          # Primeiramente, gerar o projeto nativo manualmente
          echo "Executando prebuild manual com expo..."
          npx expo prebuild --platform android --clean
          
          # Verificar se o prebuild foi bem sucedido
          if [ -d "android" ]; then
            echo "Prebuild bem sucedido! Prosseguindo com o build..."
            
            # Copiar as configurações de Gradle
            echo "Copiando configurações de Gradle..."
            cp android.gradle.properties android/
            
            # Verificar e corrigir problemas comuns de Gradle
            if [ -f "android/gradle.properties" ]; then
              echo "Atualizando gradle.properties com configurações necessárias..."
              echo "android.disableAutomaticComponentCreation=true" >> android/gradle.properties
              echo "org.gradle.jvmargs=-Xmx4g -XX:MaxPermSize=2048m -XX:+HeapDumpOnOutOfMemoryError" >> android/gradle.properties
            fi
            
            # Agora vamos tentar o build EAS
            npx eas-cli build \
              --platform android \
              --profile=${{ github.event.inputs.profile || 'preview' }} \
              --local \
              --output=./build-output/app.apk \
              --non-interactive
          else
            echo "Prebuild falhou! Tentando estratégia alternativa..."
            
            # Criar um APK básico com gradlew diretamente se o EAS falhar
            echo "Instalando ferramentas Android..."
            sudo apt-get install -y --no-install-recommends openjdk-11-jdk-headless
            
            # Criar um APK simples diretamente usando o expo
            echo "Tentando build com expo diretamente..."
            npx expo export --platform android
            mkdir -p build-output
            
            # Se o export funcionar, tentar construir com gradlew diretamente
            if [ -d "android" ]; then
              echo "Export funcionou! Tentando build com gradlew..."
              cd android
              
              # Garantir que o gradle wrapper tenha permissão de execução
              chmod +x ./gradlew
              
              # Atualizar gradle.properties para resolver problema de SoftwareComponent
              echo "android.disableAutomaticComponentCreation=true" >> gradle.properties
              
              # Tentar construir com gradlew diretamente
              ./gradlew assembleRelease --info
              
              # Verificar se o APK foi gerado
              if [ -f "app/build/outputs/apk/release/app-release.apk" ]; then
                echo "Build com gradlew bem sucedido!"
                mkdir -p ../build-output
                cp app/build/outputs/apk/release/app-release.apk ../build-output/app.apk
                cd ..
              else
                echo "Build com gradlew falhou."
                cd ..
              fi
            else
              echo "Export falhou também."
            fi
            cp -r dist/* build-output/
            
            echo "Build alternativo concluído!"
          fi
        env:
          EXPO_TOKEN: ${{ secrets.EXPO_TOKEN }}

      - name: 📤 Upload Build Artifact
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: corte-matos-apk
          path: |
            build-output/app.apk
            build-output/*.apk
          if-no-files-found: warn

      - name: ✅ Build Status
        if: always()
        run: |
          echo "Build finalizado."
          echo "Verificando diretório de saída:"
          ls -la build-output/ || true
          
          # Caso não exista nenhum APK, criar um relatório de erro detalhado
          if [ ! -f build-output/app.apk ] && [ ! -f build-output/*.apk ]; then
            echo "AVISO: Nenhum APK foi encontrado no diretório de build-output."
            echo "Tentando buscar em outros locais potenciais..."
            
            # Verificar locais alternativos onde o APK poderia estar
            find . -name "*.apk" -type f > build-output/apk-locations.txt
            
            # Verificar se algum APK foi encontrado e copiar para build-output
            if [ -s build-output/apk-locations.txt ]; then
              echo "APKs encontrados em outros locais:"
              cat build-output/apk-locations.txt
              
              # Copiar o primeiro APK encontrado para build-output
              first_apk=$(head -n 1 build-output/apk-locations.txt)
              if [ -n "$first_apk" ]; then
                cp "$first_apk" build-output/recovered-app.apk
                echo "APK recuperado e copiado para build-output/recovered-app.apk"
              fi
            else
              echo "Nenhum APK foi encontrado em qualquer lugar."
              
              # Gerar um relatório de diagnóstico detalhado
              {
                echo "===== RELATÓRIO DE DIAGNÓSTICO DE FALHA DE BUILD ====="
                echo "Data e hora: $(date)"
                echo ""
                echo "==== ESTRUTURA DO PROJETO ===="
                find . -type f -name "*.json" | sort
                echo ""
                echo "==== CONTEÚDO DO APP.JSON ===="
                cat app.json
                echo ""
                echo "==== CONTEÚDO DO EAS.JSON ===="
                cat eas.json
                echo ""
                echo "==== LOGS DE ERRO ===="
                find . -name "prebuild-*.log" -o -name "build-*.log" | xargs cat 2>/dev/null || echo "Nenhum arquivo de log encontrado"
                echo ""
                echo "===== FIM DO RELATÓRIO ====="
              } > build-output/build-diagnostic.txt
              
              echo "Relatório de diagnóstico gerado em build-output/build-diagnostic.txt"
            fi
          else
            echo "Build bem-sucedido! APK(s) encontrado(s) no diretório build-output."
            ls -la build-output/*.apk || true
          fi
          
          echo "Baixe o APK nos artefatos ou pelo dashboard do Expo."
